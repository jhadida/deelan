---
import SiteShell from '../../components/SiteShell.astro';
import { loadRelationsAnalytics, loadTagsAnalytics } from '../../lib/content/generated';
import { getSiteConfig } from '../../lib/site-config';
import { formatTimestamp } from '../../lib/time';

const tagsAnalytics = await loadTagsAnalytics();
const relationsAnalytics = await loadRelationsAnalytics();
const siteConfig = await getSiteConfig();
const generatedAt = formatTimestamp(tagsAnalytics.generated_at, siteConfig.timezone);
const avgTagsPerItem =
  tagsAnalytics.totals.items > 0
    ? (tagsAnalytics.tags.reduce((sum, tag) => sum + tag.count_total, 0) / tagsAnalytics.totals.items).toFixed(2)
    : '0.00';
---

<SiteShell pageTitle="Analytics">
  <div class="container stack analytics-page">
    <header class="page-header">
      <span class="eyebrow">Insights</span>
      <h1 class="page-title">Analytics</h1>
      <p class="page-subtitle">Generated at {generatedAt}.</p>
    </header>

    <section class="analytics-summary-grid">
      <article class="panel">
        <h2>Total items</h2>
        <p class="analytics-kpi">{tagsAnalytics.totals.items}</p>
      </article>
      <article class="panel">
        <h2>Unique tags</h2>
        <p class="analytics-kpi">{tagsAnalytics.totals.unique_tags}</p>
      </article>
      <article class="panel">
        <h2>Avg tags / item</h2>
        <p class="analytics-kpi">{avgTagsPerItem}</p>
      </article>
      <article class="panel">
        <h2>Relation edges</h2>
        <p class="analytics-kpi">{relationsAnalytics.totals.edges}</p>
      </article>
    </section>

    <section id="analytics-tag-frequency" class="panel section-block">
      <h2>Tag Frequency</h2>
      <p class="muted">Sortable table. Click column headers to sort.</p>
      <div class="table-wrap analytics-table-wrap">
        <table class="table analytics-table">
          <thead>
            <tr>
              <th>
                <button type="button" class="sort-btn" data-sort-key="name" data-sort-direction="none">
                  <span>Tag</span><span class="sort-arrows" aria-hidden="true"><span class="arrow-up">▲</span><span class="arrow-down">▼</span></span>
                </button>
              </th>
              <th>
                <button type="button" class="sort-btn" data-sort-key="count_total" data-sort-direction="none">
                  <span>Count</span><span class="sort-arrows" aria-hidden="true"><span class="arrow-up">▲</span><span class="arrow-down">▼</span></span>
                </button>
              </th>
              <th>
                <button type="button" class="sort-btn" data-sort-key="count_posts" data-sort-direction="none">
                  <span>Posts</span><span class="sort-arrows" aria-hidden="true"><span class="arrow-up">▲</span><span class="arrow-down">▼</span></span>
                </button>
              </th>
              <th>
                <button type="button" class="sort-btn" data-sort-key="count_snippets" data-sort-direction="none">
                  <span>Snippets</span><span class="sort-arrows" aria-hidden="true"><span class="arrow-up">▲</span><span class="arrow-down">▼</span></span>
                </button>
              </th>
            </tr>
          </thead>
          <tbody id="analytics-tags-table-body">
            {tagsAnalytics.tags.map((tag) => (
              <tr>
                <td>{tag.name}</td>
                <td>{tag.count_total}</td>
                <td>{tag.count_posts}</td>
                <td>{tag.count_snippets}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </section>

    <section class="panel section-block">
      <h2>Tag Hierarchy (Static Treemap)</h2>
      <p class="muted">Minimal static preview. Interactive treemap improvements are planned in future versions.</p>
      <div class="analytics-treemap-wrap">
        <div id="analytics-treemap" class="analytics-treemap" aria-label="Tag hierarchy treemap"></div>
      </div>
    </section>

    <section class="panel section-block">
      <h2>Relationships Graph</h2>
      <p class="muted">Legend: Green = post, Blue = snippet.</p>
      <div class="analytics-graph-layout">
        <div id="analytics-graph" class="analytics-graph"></div>
        <aside class="analytics-graph-side">
          <h3>Selection</h3>
          <div id="analytics-selection" class="muted">Select a node to inspect metadata.</div>
        </aside>
      </div>
    </section>
  </div>

  <script id="analytics-tags-json" type="application/json" set:html={JSON.stringify(tagsAnalytics)}></script>
  <script
    id="analytics-relations-json"
    type="application/json"
    set:html={JSON.stringify(relationsAnalytics)}
  ></script>

  <script>
    const tagsData = JSON.parse(document.getElementById('analytics-tags-json')?.textContent || '{}');
    const relationsData = JSON.parse(document.getElementById('analytics-relations-json')?.textContent || '{}');
    const tags = Array.isArray(tagsData.tags) ? [...tagsData.tags] : [];
    const tableBody = document.getElementById('analytics-tags-table-body');
    const sortButtons = Array.from(
      document.querySelectorAll('#analytics-tag-frequency .sort-btn')
    );
    const ENABLE_TAG_HISTOGRAM = false;
    let sortKey = 'count_total';
    let sortDirection = -1;

    function renderTable(rows) {
      if (!tableBody) return;
      tableBody.innerHTML = rows
        .map(
          (row) =>
            `<tr><td>${row.name}</td><td>${row.count_total}</td><td>${row.count_posts}</td><td>${row.count_snippets}</td></tr>`
        )
        .join('');
    }

    function sortedTags() {
      const rows = [...tags];
      rows.sort((a, b) => {
        if (sortKey === 'name') {
          return sortDirection * a.name.localeCompare(b.name);
        }
        return sortDirection * ((a[sortKey] ?? 0) - (b[sortKey] ?? 0));
      });
      return rows;
    }

    function syncSortIndicators() {
      sortButtons.forEach((button) => {
        const key = button.getAttribute('data-sort-key');
        const direction = key === sortKey ? (sortDirection > 0 ? 'asc' : 'desc') : 'none';
        button.setAttribute('data-sort-direction', direction);
        const th = button.closest('th');
        if (th) {
          th.setAttribute(
            'aria-sort',
            direction === 'asc' ? 'ascending' : direction === 'desc' ? 'descending' : 'none'
          );
        }
      });
    }

    sortButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const key = button.getAttribute('data-sort-key');
        if (!key) return;
        if (sortKey === key) sortDirection *= -1;
        else {
          sortKey = key;
          sortDirection = key === 'name' ? 1 : -1;
        }
        syncSortIndicators();
        renderTable(sortedTags());
      });
    });

    syncSortIndicators();
    renderTable(sortedTags());

    function buildTagTree(tagRows) {
      const roots = new Map();
      const nodeByPath = new Map();

      function ensureNode(path, name, depth, parentPath) {
        if (nodeByPath.has(path)) return nodeByPath.get(path);
        const node = { path, name, depth, parentPath, children: [], selfCount: 0, count: 0, descendants: 0 };
        nodeByPath.set(path, node);
        if (parentPath) {
          const parent = ensureNode(
            parentPath,
            parentPath.split('.').at(-1) || parentPath,
            depth - 1,
            parentPath.includes('.') ? parentPath.slice(0, parentPath.lastIndexOf('.')) : null
          );
          parent.children.push(node);
        } else {
          roots.set(path, node);
        }
        return node;
      }

      for (const tag of tagRows) {
        if (!tag?.name || !Number.isFinite(tag.count_total) || tag.count_total <= 0) continue;
        const segments = tag.name.split('.');
        let currentPath = '';
        let parentPath = null;
        for (let depth = 1; depth <= segments.length; depth += 1) {
          currentPath = currentPath ? `${currentPath}.${segments[depth - 1]}` : segments[depth - 1];
          ensureNode(currentPath, segments[depth - 1], depth, parentPath);
          parentPath = currentPath;
        }
        const leaf = nodeByPath.get(tag.name);
        if (leaf) leaf.selfCount += tag.count_total;
      }

      function aggregate(node) {
        let total = node.selfCount;
        let descendants = 0;
        for (const child of node.children) {
          total += aggregate(child);
          descendants += 1 + child.descendants;
        }
        node.count = total;
        node.descendants = descendants;
        return total;
      }

      for (const root of roots.values()) aggregate(root);
      return Array.from(roots.values()).filter((node) => node.count > 0);
    }

    function compareNodes(a, b) {
      return b.count - a.count || b.descendants - a.descendants || a.path.localeCompare(b.path);
    }

    function allocateChildHeights(children, parentHeight) {
      if (children.length === 0) return [];
      const sum = children.reduce((acc, child) => acc + child.count, 0) || 1;
      const raw = children.map((child) => (child.count / sum) * parentHeight);
      const rounded = raw.map((value) => Math.max(1, Math.round(value * 100) / 100));
      const roundedSum = rounded.reduce((acc, value) => acc + value, 0);
      const delta = Math.round((parentHeight - roundedSum) * 100) / 100;
      if (Math.abs(delta) > 0) {
        const idx = rounded.reduce((best, value, index, arr) => (value > arr[best] ? index : best), 0);
        rounded[idx] = Math.max(1, Math.round((rounded[idx] + delta) * 100) / 100);
      }
      return rounded;
    }

    function renderTreemap(tagRows) {
      const treemapEl = document.getElementById('analytics-treemap');
      if (!treemapEl) return;

      const roots = buildTagTree(tagRows).sort(compareNodes);
      if (roots.length === 0) {
        treemapEl.innerHTML = '<p class="muted">No tags to display.</p>';
        return;
      }
      const rawMinHeight = getComputedStyle(document.documentElement)
        .getPropertyValue('--analytics-treemap-min-height')
        .trim();
      const minHeight = Number.parseFloat(rawMinHeight) || 360;

      const allNodes = [];
      const queue = [...roots];
      while (queue.length > 0) {
        const node = queue.shift();
        if (!node) continue;
        allNodes.push(node);
        const sortedChildren = [...node.children].sort(compareNodes);
        queue.push(...sortedChildren);
      }

      const positiveCounts = allNodes.map((node) => node.count).filter((count) => count > 0);
      const minCount = Math.min(...positiveCounts);
      const minNodeHeightPx = 16;

      for (const node of allNodes) {
        node.h = Math.max(minNodeHeightPx, Math.round((minNodeHeightPx * node.count) / minCount * 100) / 100);
      }

      const colWidth = 220;
      const gap = 8;
      let maxDepth = 1;
      for (const node of allNodes) maxDepth = Math.max(maxDepth, node.depth);

      let yOffset = 0;
      const placed = [];

      function placeNode(node, x, y, h) {
        const sortedChildren = [...node.children].sort(compareNodes);
        placed.push({ node, x, y, w: colWidth, h });
        if (sortedChildren.length === 0) return;
        const childHeights = allocateChildHeights(sortedChildren, h);
        let childY = y;
        sortedChildren.forEach((child, index) => {
          placeNode(child, x + colWidth + gap, childY, childHeights[index]);
          childY += childHeights[index];
        });
      }

      for (const root of roots) {
        placeNode(root, 0, yOffset, root.h);
        yOffset += root.h;
      }

      const contentWidth = Math.max(
        treemapEl.parentElement?.clientWidth ?? 0,
        maxDepth * colWidth + Math.max(0, maxDepth - 1) * gap
      );
      const contentHeight = Math.max(minHeight, Math.round(yOffset));

      treemapEl.style.width = `${contentWidth}px`;
      treemapEl.style.height = `${contentHeight}px`;

      treemapEl.innerHTML = placed
        .map((piece) => {
          const style = [
            `left:${piece.x}px`,
            `top:${piece.y}px`,
            `width:${piece.w}px`,
            `height:${piece.h}px`
          ].join(';');
          return `<div class="analytics-treemap-node" style="${style}" title="${piece.node.path} (${piece.node.count})"><span>${piece.node.path}</span></div>`;
        })
        .join('');
    }

    renderTreemap(tags);

    const chartCanvas = document.getElementById('analytics-tag-chart');
    if (ENABLE_TAG_HISTOGRAM && chartCanvas instanceof HTMLCanvasElement) {
      import('chart.js/auto')
        .then(({ default: Chart }) => {
          const top = [...tags].sort((a, b) => b.count_total - a.count_total).slice(0, 20);
          new Chart(chartCanvas, {
            type: 'bar',
            data: {
              labels: top.map((entry) => entry.name),
              datasets: [
                {
                  label: 'Tag count',
                  data: top.map((entry) => entry.count_total)
                }
              ]
            },
            options: {
              indexAxis: 'y',
              responsive: true,
              plugins: {
                legend: { display: false }
              }
            }
          });
        })
        .catch((error) => {
          console.warn('Analytics chart dependency failed to load.', error);
        });
    }

    const graphEl = document.getElementById('analytics-graph');
    const selectionEl = document.getElementById('analytics-selection');
    if (graphEl) {
      import('cytoscape')
        .then(({ default: cytoscape }) => {
          const elements = [
            ...(relationsData.nodes || []).map((node) => ({ data: { ...node } })),
            ...(relationsData.edges || []).map((edge) => ({
              data: { id: `${edge.source}--${edge.target}`, source: edge.source, target: edge.target, kind: edge.kind }
            }))
          ];

          const cy = cytoscape({
            container: graphEl,
            elements,
            wheelSensitivity: 0.2,
            style: [
              {
                selector: 'node',
                style: {
                  'background-color': (ele) => (ele.data('type') === 'post' ? '#1f7a5a' : '#2878c8'),
                  label: 'data(id)',
                  color: '#f2f2f2',
                  'font-size': 10,
                  'text-wrap': 'none',
                  width: 18,
                  height: 18
                }
              },
              {
                selector: 'edge',
                style: {
                  width: 1.5,
                  'line-color': '#6b7280',
                  opacity: 0.7
                }
              }
            ],
            layout: {
              name: 'cose',
              animate: 'end',
              fit: true,
              randomize: true,
              nodeRepulsion: () => 12000,
              idealEdgeLength: () => 110,
              edgeElasticity: () => 120,
              numIter: 1200
            }
          });

          function syncZoomStyles() {
            const zoom = cy.zoom();
            const scale = Math.min(1, 1 / zoom);
            cy.style()
              .selector('node')
              .style({
                width: 18 * scale,
                height: 18 * scale,
                'font-size': 10 * scale
              })
              .selector('edge')
              .style({
                width: 1.5 * scale
              })
              .update();
          }

          syncZoomStyles();
          cy.on('zoom', syncZoomStyles);
          cy.on('dragfree', 'node', () => {
            cy.layout({
              name: 'cose',
              animate: 'end',
              fit: false,
              randomize: false,
              nodeRepulsion: () => 12000,
              idealEdgeLength: () => 110,
              edgeElasticity: () => 120,
              numIter: 500
            }).run();
          });

          cy.on('tap', 'node', (event) => {
            const data = event.target.data();
            if (!selectionEl) return;
            selectionEl.innerHTML = `
              <p>
                <a href="${data.href}" target="_blank" rel="noopener noreferrer" title="Open in new tab."><strong>${data.title}</strong></a>
              </p>
              <p>ID:
                <a href="#" class="copy-link" data-copy-link data-copy-url="${data.href}" title="Copy permalink">
                  <code>${data.id}</code>
                </a>
              </p>
              <p>Type: ${data.type}</p>
              <p>Neighbors: ${data.degree}</p>
            `;
          });
        })
        .catch((error) => {
          console.warn('Analytics graph dependency failed to load.', error);
        });
    }
  </script>
</SiteShell>
